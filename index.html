<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platonic - Cube Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .header {
            position: absolute;
            top: 20px;
            text-align: center;
            z-index: 100;
        }
        
        .game-title {
            font-size: 32px;
            font-weight: 300;
            color: #4a5568;
            margin-bottom: 5px;
            letter-spacing: 2px;
        }
        
        .level-info {
            font-size: 14px;
            color: #718096;
            opacity: 0.8;
        }
        
        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            touch-action: none;
        }
        
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            color: #4a5568;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .instructions {
            position: absolute;
            top: 80px;
            left: 20px;
            right: 20px;
            text-align: center;
            color: #718096;
            font-size: 12px;
            opacity: 0.7;
            z-index: 100;
        }
        
        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 200;
            display: none;
        }
        
        .success-title {
            font-size: 24px;
            color: #48bb78;
            margin-bottom: 10px;
        }
        
        .success-text {
            color: #4a5568;
            margin-bottom: 20px;
        }
        
        .options-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            z-index: 200;
            display: none;
            max-width: 400px;
            width: 90%;
        }
        
        .modal-title {
            font-size: 20px;
            color: #4a5568;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .option-group {
            margin-bottom: 20px;
        }
        
        .option-label {
            display: block;
            font-size: 14px;
            color: #4a5568;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .option-select, .option-range {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            font-size: 14px;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            color: #718096;
            font-size: 12px;
        }
        
        .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 25px;
        }
        
        .options-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="game-title">PLATONIC</div>
        <div class="level-info" id="levelInfo">Level 1 - 2 Slices</div>
    </div>
    
    <div class="instructions">
        Drag slices to rotate • Touch background to orbit • Two fingers to zoom • Restore the cube
    </div>
    
    <div class="game-container" id="gameContainer"></div>
    
    <div class="controls">
        <button class="btn" onclick="scramblePuzzle()">Scramble</button>
        <button class="btn" onclick="nextLevel()">Next Level</button>
        <button class="btn" onclick="resetLevel()">Reset</button>
    </div>
    
    <div class="success-message" id="successMessage">
        <div class="success-title">Perfect!</div>
        <div class="success-text">Cube restored to its original form</div>
        <button class="btn" onclick="nextLevel()">Continue</button>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let scene, camera, renderer;
        let cubeSlices = [];
        let currentLevel = 1;
        let isDragging = false;
        let selectedSlice = null;
        let mouseStart = { x: 0, y: 0 };
        let cameraRotation = { x: 0.5, y: 0.5 };
        let cameraDistance = 8;
        let isComplete = false;
        let pivotPoint;
        let lastTouchDistance = 0;
        let isZooming = false;
        let difficultySettings = {
            easy: { snapAngle: Math.PI/4, showColorSide: false, name: "Easy" },    // 45°
            normal: { snapAngle: Math.PI/6, showColorSide: true, name: "Normal" }, // 30°
            hard: { snapAngle: Math.PI/12, showColorSide: true, name: "Hard" }     // 15°
        };
        let currentDifficulty = 'easy';
        
        // Level configurations
        const levels = [
            { slices: 2, color: 0x64b5f6, complementary: 0xff6b35, name: "Azure Cube" },
            { slices: 3, color: 0x81c784, complementary: 0xc88184, name: "Jade Cube" },
            { slices: 4, color: 0xffb74d, complementary: 0x4d7bff, name: "Amber Cube" },
            { slices: 6, color: 0xf06292, complementary: 0x62f092, name: "Rose Cube" },
            { slices: 8, color: 0xba68c8, complementary: 0x68c8ba, name: "Violet Cube" }
        ];
        
        function init() {
            const container = document.getElementById('gameContainer');
            
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create pivot point for rotations
            pivotPoint = new THREE.Group();
            scene.add(pivotPoint);
            
            // Camera position
            updateCameraPosition();
            
            // Event listeners
            setupEventListeners();
            
            // Start first level
            createLevel(currentLevel);
        }
        
        function updateCameraPosition() {
            camera.position.x = cameraDistance * Math.cos(cameraRotation.x) * Math.sin(cameraRotation.y);
            camera.position.y = cameraDistance * Math.sin(cameraRotation.x);
            camera.position.z = cameraDistance * Math.cos(cameraRotation.x) * Math.cos(cameraRotation.y);
            camera.lookAt(0, 0, 0);
        }
        
        function setupEventListeners() {
            const container = document.getElementById('gameContainer');
            
            container.addEventListener('mousedown', onPointerDown, false);
            container.addEventListener('mousemove', onPointerMove, false);
            container.addEventListener('mouseup', onPointerUp, false);
            container.addEventListener('touchstart', onPointerDown, false);
            container.addEventListener('touchmove', onPointerMove, false);
            container.addEventListener('touchend', onPointerUp, false);
            
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function createLevel(levelNum) {
            // Clear previous level
            while(pivotPoint.children.length > 0) {
                pivotPoint.remove(pivotPoint.children[0]);
            }
            cubeSlices.length = 0;
            isComplete = false;
            
            const levelConfig = levels[(levelNum - 1) % levels.length];
            const sliceCount = levelConfig.slices;
            const cubeColor = levelConfig.color;
            const complementaryColor = levelConfig.complementary;
            const difficulty = difficultySettings[currentDifficulty];
            
            // Update UI
            document.getElementById('levelInfo').textContent = `Level ${levelNum} - ${sliceCount} Slices (${difficulty.name})`;
            
            // Create cube slices along Y-axis
            const sliceHeight = 2 / sliceCount;
            
            for (let i = 0; i < sliceCount; i++) {
                // Create slice geometry
                const geometry = new THREE.BoxGeometry(2, sliceHeight, 2);
                
                // Create materials array for different faces
                const materials = [];
                for (let face = 0; face < 6; face++) {
                    let faceColor = cubeColor;
                    
                    // Color the front face (index 4) with complementary color if enabled
                    if (face === 4 && difficulty.showColorSide) {
                        faceColor = complementaryColor;
                    }
                    
                    materials.push(new THREE.MeshPhongMaterial({ 
                        color: faceColor,
                        transparent: true,
                        opacity: 0.85
                    }));
                }
                
                const slice = new THREE.Mesh(geometry, materials);
                
                // Add wireframe for definition
                const wireframe = new THREE.EdgesGeometry(geometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff, 
                    opacity: 0.4, 
                    transparent: true 
                });
                const edges = new THREE.LineSegments(wireframe, wireframeMaterial);
                slice.add(edges);
                
                // Create group for rotation (each slice rotates around Y-axis)
                const sliceGroup = new THREE.Group();
                
                // Position slice at correct height
                const yPos = (i - sliceCount/2 + 0.5) * sliceHeight;
                slice.position.y = yPos;
                
                sliceGroup.add(slice);
                pivotPoint.add(sliceGroup);
                
                // Store slice data
                const sliceData = {
                    group: sliceGroup,
                    mesh: slice,
                    targetRotation: 0,
                    currentRotation: 0,
                    index: i
                };
                
                cubeSlices.push(sliceData);
            }
            
            // Scramble after creation
            setTimeout(() => scramblePuzzle(), 500);
        }
        
        function scramblePuzzle() {
            if (isComplete) return;
            
            const difficulty = difficultySettings[currentDifficulty];
            const snapAngle = difficulty.snapAngle;
            
            cubeSlices.forEach((slice, index) => {
                if (slice && slice.group) {
                    // Generate random rotation in multiples of snap angle
                    const maxRotations = Math.round(Math.PI * 2 / snapAngle);
                    const possibleRotations = [];
                    for (let i = 1; i < maxRotations; i++) { // Start from 1 to exclude 0 rotation
                        possibleRotations.push(i * snapAngle);
                    }
                    
                    // Pick random rotation
                    const randomRotation = possibleRotations[Math.floor(Math.random() * possibleRotations.length)];
                    
                    // Animate to scrambled position for better visual feedback
                    setTimeout(() => {
                        slice.group.rotation.y = randomRotation;
                        slice.currentRotation = randomRotation;
                    }, index * 100);
                }
            });
        }
        
        function getIntersectedSlice(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const meshes = cubeSlices.map(slice => slice.mesh).filter(mesh => mesh);
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                // Find which slice this mesh belongs to
                for (let slice of cubeSlices) {
                    if (slice && slice.mesh === intersects[0].object) {
                        return slice;
                    }
                }
            }
            return null;
        }
        
        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function onPointerDown(event) {
            event.preventDefault();
            if (isComplete) return;
            
            // Handle two-finger zoom
            if (event.touches && event.touches.length === 2) {
                isZooming = true;
                isDragging = false;
                lastTouchDistance = getTouchDistance(event.touches);
                return;
            }
            
            isDragging = true;
            isZooming = false;
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            mouseStart.x = clientX;
            mouseStart.y = clientY;
            
            selectedSlice = getIntersectedSlice(event);
            
            if (selectedSlice && selectedSlice.mesh) {
                // Highlight selected slice
                if (Array.isArray(selectedSlice.mesh.material)) {
                    selectedSlice.mesh.material.forEach(material => {
                        if (material) {
                            material.opacity = 1.0;
                            material.emissive.setHex(0x222222);
                        }
                    });
                } else if (selectedSlice.mesh.material) {
                    selectedSlice.mesh.material.opacity = 1.0;
                    selectedSlice.mesh.material.emissive.setHex(0x222222);
                }
            }
        }
        
        function onPointerMove(event) {
            if (!isDragging && !isZooming) return;
            
            // Handle two-finger zoom
            if (event.touches && event.touches.length === 2 && isZooming) {
                const currentDistance = getTouchDistance(event.touches);
                const zoomDelta = (currentDistance - lastTouchDistance) * 0.01;
                cameraDistance = Math.max(4, Math.min(15, cameraDistance - zoomDelta));
                updateCameraPosition();
                lastTouchDistance = currentDistance;
                return;
            }
            
            if (!isDragging) return;
            
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            const deltaX = clientX - mouseStart.x;
            const deltaY = clientY - mouseStart.y;
            
            if (selectedSlice) {
                // Rotate selected slice around Y-axis based on horizontal drag
                const rotationSpeed = 0.01;
                selectedSlice.currentRotation += deltaX * rotationSpeed;
                selectedSlice.group.rotation.y = selectedSlice.currentRotation;
            } else {
                // Rotate camera view
                cameraRotation.y += deltaX * 0.005;
                cameraRotation.x += deltaY * 0.005;
                cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                updateCameraPosition();
            }
            
            mouseStart.x = clientX;
            mouseStart.y = clientY;
        }
        
        function onPointerUp(event) {
            isDragging = false;
            isZooming = false;
            
            if (selectedSlice && selectedSlice.mesh) {
                const difficulty = difficultySettings[currentDifficulty];
                const snapAngle = difficulty.snapAngle;
                
                // Remove highlight
                if (Array.isArray(selectedSlice.mesh.material)) {
                    selectedSlice.mesh.material.forEach(material => {
                        if (material) {
                            material.opacity = 0.85;
                            material.emissive.setHex(0x000000);
                        }
                    });
                } else if (selectedSlice.mesh.material) {
                    selectedSlice.mesh.material.opacity = 0.85;
                    selectedSlice.mesh.material.emissive.setHex(0x000000);
                }
                
                // Snap to nearest increment based on difficulty
                const snappedRotation = Math.round(selectedSlice.currentRotation / snapAngle) * snapAngle;
                selectedSlice.currentRotation = snappedRotation;
                selectedSlice.group.rotation.y = snappedRotation;
                
                // Check if this slice is now correctly aligned (rotation = 0)
                const normalizedRotation = ((snappedRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                if (Math.abs(normalizedRotation) < 0.1 || Math.abs(normalizedRotation - Math.PI * 2) < 0.1) {
                    // Visual feedback for correct alignment
                    if (Array.isArray(selectedSlice.mesh.material)) {
                        selectedSlice.mesh.material.forEach(material => {
                            if (material && material.color) {
                                const originalColor = material.color.getHex();
                                material.color.setHex(0xffffff);
                                setTimeout(() => {
                                    material.color.setHex(originalColor);
                                }, 200);
                            }
                        });
                    } else if (selectedSlice.mesh.material && selectedSlice.mesh.material.color) {
                        const originalColor = selectedSlice.mesh.material.color.getHex();
                        selectedSlice.mesh.material.color.setHex(0xffffff);
                        setTimeout(() => {
                            selectedSlice.mesh.material.color.setHex(originalColor);
                        }, 200);
                    }
                }
                
                selectedSlice = null;
                checkCompletion();
            }
        }
        
        function checkCompletion() {
            // Check if all slices form a complete cube (all rotations at 0°)
            let correctSlices = 0;
            const tolerance = 0.15;
            const difficulty = difficultySettings[currentDifficulty];
            
            cubeSlices.forEach(slice => {
                if (slice && slice.group) {
                    const normalizedRotation = ((slice.currentRotation % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    // Check if rotation is close to 0 or 2π (full rotation)
                    if (Math.abs(normalizedRotation) < tolerance || 
                        Math.abs(normalizedRotation - Math.PI * 2) < tolerance) {
                        correctSlices++;
                    }
                }
            });
            
            if (correctSlices === cubeSlices.length && cubeSlices.length > 0) {
                isComplete = true;
                document.getElementById('successMessage').style.display = 'block';
                
                // Celebration effect - flash all slices white then back to original color
                cubeSlices.forEach((slice, index) => {
                    if (slice && slice.mesh) {
                        setTimeout(() => {
                            if (Array.isArray(slice.mesh.material)) {
                                slice.mesh.material.forEach(material => {
                                    if (material && material.color) {
                                        const originalColor = material.color.getHex();
                                        material.color.setHex(0xffffff);
                                        setTimeout(() => {
                                            material.color.setHex(originalColor);
                                        }, 150);
                                    }
                                });
                            } else if (slice.mesh.material && slice.mesh.material.color) {
                                const originalColor = slice.mesh.material.color.getHex();
                                slice.mesh.material.color.setHex(0xffffff);
                                setTimeout(() => {
                                    slice.mesh.material.color.setHex(originalColor);
                                }, 150);
                            }
                        }, index * 80);
                    }
                });
            }
        }
        
        function cycleDifficulty() {
            const difficulties = ['easy', 'normal', 'hard'];
            const currentIndex = difficulties.indexOf(currentDifficulty);
            currentDifficulty = difficulties[(currentIndex + 1) % difficulties.length];
            
            // Recreate level with new difficulty
            createLevel(currentLevel);
        }
        
        function nextLevel() {
            document.getElementById('successMessage').style.display = 'none';
            currentLevel++;
            
            // Auto-progress difficulty every 2 levels
            if (currentLevel > 2 && currentDifficulty === 'easy') {
                currentDifficulty = 'normal';
            } else if (currentLevel > 4 && currentDifficulty === 'normal') {
                currentDifficulty = 'hard';
            }
            
            createLevel(currentLevel);
        }
        
        function resetLevel() {
            document.getElementById('successMessage').style.display = 'none';
            createLevel(currentLevel);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Initialize game
        init();
        animate();
    </script>
</body>
</html>